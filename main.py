"""
Final 355 Group Project
main.py

Tigger Wong 		20673283
Rachel DiMaio	    20704330
Erin Roulston 		20718053
Emily Bauer 		20727725
Sarah Schwartzel 	20710946
2020/03/21
"""

import collecations
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import Ridge
from scipy.optimize import fsolve
from scipy.special import expit
from scipy.integrate import solve_ivp, quad, dblquad
import math
import sympy as sym

"""
alphaF # is the angular motion of the foot. alphaF = 0 when foot is horizontal
angleS # is the shank orientation in 3D space. angleS = 0 when shank is vertical
omegaS # is the angular velocity of the shank
ax,A # is the acceleration of the ankle in the x-direction
aY,A # is the acceleration of the ankle in the y-direction
Tgrav # is the torque generated by gravity
mF # is the mass of the foot
cF # is the foot’s center of mass location with respect to the ankle
TTA # is the torque generated by the tibialis anterior
d # is the lever arm of the tibialis anterior at the ankle. d = 0.037
FTA # is the muscle force of the tibialis anterior. FTA = FCE + FPE + FPD 
FPE # is the parallel elastic force
FPD # is the parallel damping element force
FCE # is the force in the contractile element. FCE = Fiso,max* fad* ftl* ffv
fad # is the activation level. 0 ≤ fad ≤ 1
muscle_excitation # is the muscle excitation. 0 ≤ muscle_excitation  ≤ 1
Tact # is the time constant for activation. Tact = 0.04s
Tdeact # is the time constant for deactivation. Tdeact = 0.04s
lMT # is the length of the muscle-tendon complex for the tibialis anterior. lMT = lMT,0 - dankle*phi
lMT,0 # is the rest length.  lMT,0 = 0.381
phi # is the current relative angle at the foot. phi :=  angleS - alphaF. phi = 0 when there is a right angle at the ankle
lT # is the tendon length constant. lT = 0.317
lCE # is the length of the contractile element. lCE = lMT - lT  
VCE # is the contraction speed of the muscle. VCE =  - dankle*phi (*** the phi has a lil dot on him but idk how to draw it)
ffl # is the force-length factor. ffl = 
ICE, opt # is the fiber length at which the optimum force can be generated. ICE, opt = 0.082
W # is the width parameter describing the overlapping of filaments in the sarcomere. W = 0.56
ffv # is the force-velocity factor. It models the dependency of the muscle force on the contraction speed of the muscle. ffv =  if vCE  > 0 (extension).  ffv = else (contraction)
gmax = 0.82
LCE, opt = 0.82   
#---- not complete (but almost) ----
"""
class Gaussian:
    def __init__(self, mu, sigma):
        self.mu = mu
        self.sigma = sigma

    def __call__(self, x):
        return np.exp(-(x-self.mu)**2/2/self.sigma**2)


class Sigmoid:
    def __init__(self, mu, sigma):
        self.mu = mu
        self.sigma = sigma

    def __call__(self, x):
        return expit((x-self.mu) / self.sigma)


class Regression():
    """
    1D regression model with Gaussian basis functions.
    """

    def __init__(self, x, t, centres, width, regularization_weight=1e-6, sigmoids=False):
        """
        :param x: samples of an independent variable
        :param t: corresponding samples of a dependent variable
        :param centres: a vector of Gaussian centres (should have similar range of values as x)
        :param width: sigma parameter of Gaussians
        :param regularization_weight: regularization strength parameter
        """
        if sigmoids:
            self.basis_functions = [Sigmoid(centre, width) for centre in centres]
        else:
            self.basis_functions = [Gaussian(centre, width) for centre in centres]
        self.ridge = Ridge(alpha=regularization_weight, fit_intercept=False)
        self.ridge.fit(self._get_features(x), t)

    def eval(self, x):
        """
        :param x: a new (or multiple samples) of the independent variable
        :return: the value of the curve at x
        """
        return self.ridge.predict(self._get_features(x))

    def _get_features(self, x):
        if not isinstance(x, collections.Sized):
            x = [x]

        phi = np.zeros((len(x), len(self.basis_functions)))
        for i, basis_function in enumerate(self.basis_functions):
            phi[:,i] = basis_function(x)
        return phi

class SwingPhase:
    def __init__(self, muscle_excitation):
        self.resting_MT_length = 0.381
        EED self.mass_foot = 1.05           # mF is the mass of the foot (kg)   # (this value is from anthropometric data)
        self.foot_center = 0.08         # cF is the foot’s center of mass location with respect to the ankle # WHERE FROM?
        self.lever_arm = 0.037          # d is the lever arm of the tibialis anterior at the ankle. d = 0.037
        self.tendon_length = 0.317      # lT is the tendon length constant. lT = 0.317
        self.time_activation = 0.04     # is the time constant for activation. Tact = 0.04s
        self.time_deactivation = 0.04   # is the time constant for deactivation. Tdeact = 0.04s  
        self.gmax = 0.82                # idk what this is for
        self.LCE_opt = 0.082            # optimal contractile element length (fibre length at which optimal force can be generated)
        self.width_parameter = 0.56     # describing the overlapping of filaments in the sarcomere
        self.v_max = 0                  # Graphs were found that showed the velocity of the TA throughout the gait cycle.
                                        # https://www.researchgate.net/figure/Fig7-Simulation-results-of-walking-as-walking-speed-increases-from-60-to-120-PTS-for_fig2_7978272
                                        # 
        self.max_isometric_force = 0    # NOT SURE YET
        self.muscle_excitation = muscle_excitation


    def get_angular_acceleration_foot(self):        # derivative of w_f
        return ((self.get_TA_torque() + self.get_gravity_torque() + self.mass_foot*self.foot_center*(self.get_ankle_x_acceleration()*math.sin(self.get_angle_foot()) - self.get_ankle_y_acceleration()*math.cos(self.get_angle_foot)))/(self.get_moment_of_inertia + self.mass_foot * (self.foot_center)**2))

    def get_angle_foot(self):   # alphaF is the angular motion of the foot. alphaF = 0 when foot is horizontal
        #get the integral of angular acceleration
        #get the integral of that integral
        return dblquad(self.get_angular_acceleration_foot(), 0, t) #replace t with something that isn't nonsensical
    
    def get_angle_shank(self):  # angleS is the shank orientation in 3D space. angleS = 0 when shank is vertical
        # integral of angular velocity of shank
        return 0
    
    def get_angular_velocity_shank():   # omegaS is the angular velocity of the shank; THIS IS A CONTROL VARIABLE (we have to provide values)
        return 0
    
    def get_ankle_x_acceleration(): # ax,A  is the acceleration of the ankle in the x-direction; THIS IS A CONTROL VARIABLE (we have to provide values)
        ankle_x_velocity_function = get_ankle_velocity_x_regression()
        x = sym.symbols('x')
        ankle_x_acceleration_function = sym.diff(ankle_x_velocity_function)
        ankle_x_accelerations = ankle_x_acceleration_function.evalf(subs={x:44}) #NOT SURE - change 44 (placeholder)
        return ankle_x_accelerations
    
    def get_ankle_y_acceleration(): # aY,A is the acceleration of the ankle in the y-direction; THIS IS A CONTROL VARIABLE (we have to provide values)
        ankle_y_velocity_function = get_ankle_velocity_y_regression()
        x = sym.symbols('x')
        ankle_y_acceleration_function = sym.diff(ankle_y_velocity_function)
        ankle_y_accelerations = ankle_y_acceleration_function.evalf(subs={x:44}) #NOT SURE - change 44 (placeholder)
        return ankle_y_accelerations
    
    def get_gravity_torque(self):   # Tgrav is the torque generated by gravity
        return -1*self.foot_center * math.cos(self.get_angle_foot()) * self.mass_foot * 9.81
    
    def get_TA_torque(self): #TTA is the torque generated by the tibialis anterior
        return self.get_TA_force() * self.lever_arm
    
    def get_TA_force(self):     # FTA is the muscle force of the tibialis anterior. FTA = FCE + FPE + FPD 
        return self.get_contractile_element_force() + self.get_parallel_elastic_force() + self.get_parallel_dampening_force()
    
    def get_parallel_elastic_force():   #FPE is the parallel elastic force 
        #The following website has a force length curve for the TA that could be used to find K values as per Professor Tripp's email.
        #https://www.researchgate.net/figure/Optimized-force-length-FL-left-column-force-extension-FL-middle-column-and_fig2_51879942
        #Data points were collected from the FdeltaL graph for the TA using webplot digitizer.
        #The points were put into excel, where we calculate the slope between two of the collected points.
        #This resulted in a value of approximately 27.8, which will be used for K.

        return 0
    
    def get_parallel_dampening_force(self): # FPD is the parallel damping element force
        b = 0.001*self.max_isometric_force/self.LCE_opt
        return b*self.get_contraction_speed
    
    def get_contractile_element_force(self):    # FCE is the force in the contractile element. FCE = Fiso,max* fad* ftl* ffv
        return self.max_isometric_force * self.get_activation_level() * self.force_length_factor * self.force_velocity_factor()
    
    def get_activation_level(): # fad is the activation level. 0 ≤ fad ≤ 1
        def activation_dot(fad):
            return (self.muscle_excitation - fad)*(self.muscle_excitation/self.time_activation - (1-self.muscle_excitation)/self.time_deactivation)
        sol = solve_ivp(activation_dot, [0, 0.3], [1], rtol = 1e-5, atol = 1e-8)
        return 
    
    def force_length_factor(self): 
        return math.exp(-1*((self.get_CE_length - self.LCE_opt)/(self.width_parameter*self.LCE_opt))**2)
    
    def force_velocity_factor(self): 
        return (self.get_lambda*self.v_max + self.get_continuous_derivative_factor)/(self.get_lambda*self.v_max - self.get_contraction_speed/0.25)
    
    def get_relative_angle_foot(self):  # is the current relative angle at the foot. phi :=  angleS - angleF. phi = 0 when there is a right angle at the ankle
        return (self.get_angle_shank() - self.get_angle_foot())
    
    def get_MT_length(self): # is the length of the muscle-tendon complex for the tibialis anterior. lMT = lMT,0 - dankle*phi
        return self.resting_MT_length - self.lever_arm*self.get_relative_angle_foot()
    
    def get_CE_length(self): # is the length of the contractile element. lCE = lMT - lT  
        return self.get_MT_length() - self.tendon_length
    
    def get_lambda(self):
        return (1 - math.exp(-3.82 * self.get_activation_level()) + self.get_activation_level() * math.exp(-3.82))
    
    def get_contraction_speed(self): # is the contraction speed of the muscle. VCE =  - dankle*phi
        x = sym.symbols('x')
        derivative_function = sym.diff(self.get_relative_angle_foot(x))
        relative_angular_velocity = derivative_function.evalf(subs={x:44})#NOT SURE - change 44
        return -1*self.lever_arm*relative_angular_velocity
    
    def get_continuous_derivative_factor(self): 
        return ((self.get_lambda() * self.v_max * 0.25 * (self.gmax - 1))/(0.25 + 1))

    def get_moment_of_intertia():
        # assuming the foot to be a thin rod, I = Ml^2/12
        # using the journal of eng science and tech paper:
        # length of foot is 0.26 m
        return (self.mass_foot*0.26)/12
        
"""
Swing phase between 0 and 0.3 -  80% of swing cycle
"""
# multiple functions to model/optimise epsilon
# define function

def muscle_excitation_1(time):
    percents = (time / 0.375 * 100) % 100
    muscle_excitations = []
    for percent in percents:
        if percent < 0:
            print("this is an issue! (x is less than 0)")
            muscle_excit = 0
        elif percent < 10:
            muscle_excit = percent / 10
        elif percent < 30:
            muscle_excit = 1
        elif percent < 40:
            muscle_excit = -percent / 20 + 2.5
        elif percent < 60:
            muscle_excit = 0.5
        elif percent < 80:
            muscle_excit = -percent / 40 + 2
        else:
            muscle_excit = 0
        muscle_excitations.append(muscle_excit)

    return muscle_excitations

def muscle_excitation_2(time):
    percents = (time/0.375 *100)%100
    muscle_excitations = []
    for percent in percents:
        if percent < 0:
            print("this is an issue! (x is less than 0)")
            muscle_excit = 0
        elif percent < 15:
            muscle_excit = 1
        else:
            muscle_excit = 2 ** (-1 * (percent - 12.678)) + 0.3

        muscle_excitations.append(muscle_excit)

    return muscle_excitations

def get_angular_position_shank_regression():
    data = np.array([
        [0.0009216589861751195, -56.22489959839358],
        [0.009216589861751154, -58.15261044176707],
        [0.017165898617511527, -59.91967871485943],
        [0.025806451612903236, -60.72289156626506],
        [0.03444700460829493, -61.365461847389554],
        [0.043433179723502316, -61.84738955823293],
        [0.052073732718894025, -62.00803212851406],
        [0.06105990783410138, -62.00803212851406],
        [0.06935483870967744, -61.68674698795181],
        [0.0783410138248848, -60.40160642570282],
        [0.08698156682027645, -59.43775100401605],
        [0.09562211981566822, -57.83132530120483],
        [0.10391705069124428, -55.42168674698797],
        [0.11290322580645167, -53.493975903614455],
        [0.12154377880184329, -51.24497991967873],
        [0.13018433179723504, -49.15662650602411],
        [0.13917050691244243, -46.586345381526115],
        [0.14746543778801846, -44.016064257028106],
        [0.1557603686635945, -40.48192771084338],
        [0.16543778801843317, -37.59036144578313],
        [0.17373271889400915, -34.377510040160644],
        [0.18202764976958524, -31.485943775100395],
        [0.19101382488479263, -28.273092369477908],
        [0.2, -24.738955823293168],
        [0.20829493087557605, -21.526104417670673],
        [0.21658986175115208, -18.313253012048186],
        [0.22557603686635946, -14.13654618473894],
        [0.23456221198156685, -9.959839357429708],
        [0.24320276497695859, -6.4257028112449746],
        [0.25184331797235027, -3.212851405622473],
        [0.26912442396313363, 4.819277108433752],
        [0.27741935483870966, 8.192771084337366],
        [0.28640552995391705, 11.566265060240983],
        [0.29539170506912443, 14.136546184738979],
        [0.3043778801843318, 16.706827309236967],
        [0.3126728110599078, 18.313253012048218],
        [0.32096774193548383, 19.277108433734963],
        [0.3306451612903226, 19.277108433734963],
        [0.26013824884792625, 0.963855421686759]
    ])

    times = data[:, 0]
    angle = data[:, 1]

    centres = np.arange(0, 0.3, 0.1)
    width = .15
    
    angular_position_function = Regression(times, angle, centres, width, 0.1, sigmoids = False)
    return angular_position_function


def get_ankle_velocity_x_regression():
    data_x = np.array([
        [0.3082731651404498, 0.0718252975197391],
        [0.35319441526574646, 0.18044085752418848],
        [0.39818271203302125, 0.31621030752975],
        [0.42855484084908024, 0.56059531753976],
        [0.4588599230231609, 0.777826437548657],
        [0.48433764697482173, 1.0493653375597791],
        [0.5250349586555012, 1.4566736875764636],
        [0.531002109791548, 1.8639820375931473],
        [0.5520547553726574, 2.3527520576131664],
        [0.5829632573245407, 2.814368187632075],
        [0.6386119701663262, 3.248830427649871],
        [0.659128242611611, 3.520369327660993],
        [0.7147099088114186, 3.927677677677677],
        [0.7743814201718875, 3.981985457679901],
        [0.818162877383557, 3.6289848876654425],
        [0.8419644352857665, 3.221676537648759],
        [0.8408246423721395, 2.760060407629851],
        [0.8747502432130354, 2.4342137276165037],
        [0.8786389484477628, 1.9997514875987088],
        [0.8777673421020482, 1.6467509175842494],
        [0.8969426817077719, 1.3752120175731273],
        [0.911424756375032, 1.2122886775664536],
        [0.9305330493387773, 0.9135958875542185],
        [0.9550721203027452, 0.80498032754977],
        [0.974448599834403, 0.6149030975419842],
        [0.9739792733405566, 0.4248258675341985],
        [1.0031445626010107, 0.18044085752418848]
    ])

    times_x = data_x[:,0]
    velocity_x = data_x[:,1]
    
    times_x = times_x - min(times_x)
    
    centres = np.arange(0, 1, .2)
    width = .15
    regression_function = Regression(times_x, velocity_x, centres, width, .1, sigmoids=False)
    return regression_function

def get_ankle_velocity_y_regression():
    data_y = np.array([
        [0.3217579299395332, 0.0908016079451408],
        [0.3795561260683038, 0.13208120798567702],
        [0.4112758842009254, 0.21551869742931462],
        [0.4365435935547073, 0.2990237475931492],
        [0.46181130290848893, 0.38252879775698423],
        [0.4739046718238016, 0.5080566158835254],
        [0.47995135628145813, 0.5708205249467959],
        [0.47934330979968265, 0.6650677296219978],
        [0.5046110191534641, 0.7485727797858328],
        [0.5105225821707258, 0.8322805121102594],
        [0.5230888761274197, 0.8845049488227545],
        [0.5291355605850756, 0.9472688578860253],
        [0.5288653177042866, 0.989156504408337],
        [0.5349795628821401, 1.0414485018410296],
        [0.5410938080599939, 1.0937404992737223],
        [0.5470053710772558, 1.177448231598149],
        [0.5465324460358749, 1.2507516130121947],
        [0.5590311792723708, 1.313447961355268],
        [0.5779144005675099, 1.386548660608722],
        [0.5967300611424515, 1.4701212714927543],
        [0.6219977704962336, 1.5536263216565889],
        [0.6538526500692496, 1.6161199878390704],
        [0.6670269905077186, 1.574097219876364],
        [0.6928351856230788, 1.573826976995575],
        [0.7060095260615475, 1.5318042090328685],
        [0.7255683545586591, 1.5001857919805426],
        [0.7449920616153769, 1.4895111981893727],
        [0.7646184508326856, 1.447420869506469],
        [0.7713407424923149, 1.4054656622639599],
        [0.7780630341519437, 1.3635104550214507],
        [0.7783332770327329, 1.3216228084991388],
        [0.7786035199135217, 1.279735161976827],
        [0.7982299091308309, 1.2376448332939232],
        [0.8114042495693006, 1.1956220653312166],
        [0.8247137114481642, 1.132655474107354],
        [0.8251866364895448, 1.0593520926933082],
        [0.8255244400905315, 1.0069925345404183],
        [0.8321116103097659, 0.985981150559065],
        [0.8390365841299869, 0.912610208424822],
        [0.8589332162280849, 0.8286322332196066],
        [0.8593385805492686, 0.7658007634361386],
        [0.878086680404013, 0.8598452859507486],
        [0.8905854136405094, 0.9225416342938217],
        [0.8835928791000913, 1.0063844880586428],
        [0.9105496064588048, 0.8280917474580283],
        [0.904435361280951, 0.7757997500253355],
        [0.9111576529405803, 0.7338445427828264],
        [0.9114954565415669, 0.6814849846299362],
        [0.9119008208627506, 0.6186535148464685],
        [0.9121710637435394, 0.5767658683241565],
        [0.9252102827416142, 0.5556869236226061],
        [0.925412964902206, 0.524271188730872],
        [0.9258858899435867, 0.4509678073168262],
        [0.9320676958416378, 0.4927878931189409],
        [0.9327433030436103, 0.388068776813161],
        [0.9325406208830185, 0.4194845117048951],
        [0.926629057865757, 0.3357767793804687],
        [0.9268993007465458, 0.29388913285815654],
        [0.9271695436273351, 0.2520014863358444],
        [0.9338242745667669, 0.22051819072391332],
        [0.9469310542850387, 0.1889673343917848],
        [0.959902712562916, 0.17836030132081193],
        [0.9795291017802248, 0.1362699726379084],
        [0.979799344661014, 0.09438232611559627],
        [0.9800020268216059, 0.06296659122386261],
        [0.9804073911427895, 0.00013512144039484753]
    ])
    
    
    times_y = data_y[:,0]
    velocity_y = data_y[:,1]
    
    times_y = times_y - min(times_y)
    
    centres2 = np.arange(0, 1, .2)
    width2 = .15
    regression_function2 = Regression(times_y, velocity_y, centres2, width2, .1, sigmoids=False)

    return regression_function2
    